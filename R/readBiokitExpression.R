#' Internal function used by readBiokitExpression
#' 
#' 
#' @param keys A vector of character strings
#' @param dfList A list of data.frames to be matched
#' @param keyColumn The column of keys in the data.frames of dfList
#' @param valueColumns One or more character strings, column names in the
#' data.frames of dfList
#' 
#' #@importFrom ribiosUtils matchColumn
#' @return A list of matrices, each containing one value column
matchKeyValue <- function(keys, dfList, keyColumn, valueColumns) {
  subdfList <- lapply(dfList, 
                      function(x) matchColumn(keys, x, keyColumn)[, valueColumns])
  resList <- lapply(valueColumns, function(col) {
    res <- do.call(cbind, lapply(subdfList, function(x) x[,col]))
    rownames(res) <- keys
    res[is.na(res)] <- 0
    return(res)
  })
  return(resList)
}

#' Read Biokit Expression files
#' 
#' @param files One or more expression files generated by the Biokit software
#' @param exprsType Which data types should become the exprs element of the
#' resulting ExpressionSet.
#' @param ngsPipelineSampleInfoFile Sample info file used by Roche
#' Bioinformatics NGS pipeline, a headerless TSV file including sample name,
#' sample group, and FASTQ files, one sample per line
#' 
#' \code{readBiokitExpression} calls \code{\link[ribiosIO]{read_biokit_exprs}}
#' to read #' BioKit expression data, and combine data from multiple files 
#' into one \code{ExpressionSet} object.
#' 
#' @importFrom ribiosIO read_biokit_exprs 
#' @importFrom Biobase `sampleNames<-`
#' @importFrom utils read.table
#' @importFrom ribiosUtils matchColumn basefilename
#' @importClassesFrom Biobase ExpressionSet AnnotatedDataFrame
#' @examples
#' 
#' biokitFiles <- system.file("extdata/biokit_expression_files",
#'   sprintf("biokit-output-%d.expression", 1:4),
#'   package="ribiosNGS")
#' biokitEset <- readBiokitExpression(biokitFiles)
#' 
#' @export readBiokitExpression
readBiokitExpression <- function(files,
                                 exprsType=c("ReadCount_UniqMap", "RPKM_UniqMap",
                                             "ReadCount_MultiMap", "RPKM_MultiMap",
                                             "AllMappingReads"),
                                 ngsPipelineSampleInfoFile=NULL) {
  exprsType <- match.arg(exprsType)
  tbls <- lapply(files, read_biokit_exprs)
  featTbls <- lapply(tbls, function(x) {
    annoCols <- grepl("^Annotation", colnames(x))
    res <- data.frame(Feature=rownames(x),
                      x[,annoCols])
    return(res)
  })
  featTbl <- unique(do.call(rbind, featTbls))
  uniqFeatures <- featTbl$Feature
  rownames(featTbl) <- uniqFeatures
  valueCols  <- c("RPKM_MultiMap","ReadCount_MultiMap",
                  "RPKM_UniqMap","ReadCount_UniqMap",
                  "MultiProp", "AllMappingReads")
  valueNames <- valueCols; valueNames[valueCols == exprsType] <- "exprs"
  valueMats <- matchKeyValue(uniqFeatures, tbls, 0L, valueCols)
  resEnv <- new.env()
  sapply(seq(along=valueCols), function(i) assign(x=valueNames[i], 
                                                  value=valueMats[[i]],
                                                  envir=resEnv))
  res <- new("ExpressionSet",
             assayData=resEnv,
             featureData=new("AnnotatedDataFrame", featTbl))
  sampleNames(res) <- basefilename(files)
  if(!is.null(ngsPipelineSampleInfoFile)) {
    sampleInfo <- utils::read.table(ngsPipelineSampleInfoFile, head=FALSE,
                             col.names=c("SampleName", "SampleGroup", "Fastq1", "Fastq2"))
    sampleInfo <- ribiosUtils::matchColumn(sampleNames(res), sampleInfo, "SampleName")
    rownames(sampleInfo) <- sampleNames(res)
    pData(res) <- sampleInfo
  }
  return(res)
}


#' Read GCT files from Biokit output directory
#' 
#' 
#' @param dir Biokit output directory
#' @param anno Annotation type, either \code{refseq} or \code{ensembl} is
#' supported
#' @param type GCT file type, \code{count}, \code{tpm}, \code{count_collapsed}, 
#'   \code{tpm_collapsed}, and \code{log2tpm} are supported.
#' @return A numeric matrix with the attribute \code{desc} encoding the values
#'   in the description column of the GCT format.
#' @examples
#' 
#' ##... (TODO: add a mock output directory in testdata)
#' 
#' @importFrom ribiosIO read_gct_matrix
#' @export readBiokitGctFile
readBiokitGctFile <- function(dir, 
                              anno=c("refseq", "ensembl"),
                              type=c("count", "tpm", "count_collapsed", 
                                     "tpm_collapsed", "log2tpm")) {
  anno <- match.arg(anno)  
  type <- match.arg(type)
  
  annoPath <- switch(anno,
                     "refseq"="gct",
                     "ensembl"="gct-ens")
  
  gctDir <- file.path(dir, annoPath) 
  assertDir(gctDir)
  
  filePattern <- switch(type,
                        "count"=".*_count.gct",
                        "tpm"=".*_tpm.gct",
                        "count_collapsed"=".*_count_collapsed.gct",
                        "tpm_collapsed"=".*_tpm_collapsed.gct")
  
  gctFile <- dir(gctDir, pattern=filePattern, full.names=TRUE)
  if(length(gctFile)==0 || !file.exists(gctFile))
    stop(paste0("GCT file with the pattern'", filePattern, "' does not exist!"))
  mat <- ribiosIO::read_gct_matrix(gctFile)
  return(mat)
}

#' Read Biokit phenodata
#' 
#' @param dir Character string, Biokit output directory
#' @return A \code{data.frame} with sample annotation in columns, and sample 
#'   names (identical as the names in gct files, character strings) are row 
#'   names. Nmes of the first three columns are fixed:
#'   \enumerate{
#'     \item \code{SampleName}, \code{SampleID} and \code{group} concatenated by 
#'        underscore
#'     \item \code{SampleID}
#'     \item \code{group}
#'   }
#' @export
readBiokitPhenodata <- function(dir) {
  ## read sample annotation from annot/phenoData.meta
  phenoDataFile <- file.path(dir, "annot", "phenoData.meta")
  ribiosUtils::assertFile(phenoDataFile)
  
  ## to have consistent formats of sample annotation, we rename the frist three columns of annot
  annot <- ribiosIO::readTable(phenoDataFile, row.names=FALSE)
  colnames(annot)[1:3] <- c("SampleName", "SampleID", "group")
  annotSampleName <- as.character(annot[, 1L])
  annotSampleId <- annot[, 2L]
  annotSampleGroup <- annot[, 3L]
  rownames(annot) <- annotSampleName
  
  return(annot)
}

#' Read feature annotation from Biokit directory
#' 
#' @param dir Character string, a Biokit output directory.
#' @param anno Character, indicating the annotation type.
#' @return A \code{data.frame} containing feature annotation, with feature IDs 
#'   as characters in rownames. The data frame contains following columns 
#'   depending on the \code{anno} parameter: 
#'   \enumerate{
#'     \item FeatureID
#'     \item GeneID (refseq only) or EnsemblID (ensembl only)
#'     \item GeneSymbol
#'     \item mean: mean length
#'     \item median: median length
#'     \item longest_isoform: longest isoform
#'     \item merged: total length of merged exons
#'   }
#' @export
#' @examples 
#' ## TODO add small example files
readBiokitFeatureAnnotation <-
  function(dir, anno = c("refseq", "ensembl")) {
    anno <- match.arg(anno)
    annoDir <- file.path(dir, "annot")
    if (anno == "refseq")  {
      annotFile <- file.path(annoDir, "refseq.annot.gz")
      lenFile <- file.path(annoDir, "refseq.geneLength.gz")
    } else if (anno == "ensembl") {
      annotFile <- file.path(annoDir, "ensembl.annot.gz")
      lenFile <- file.path(annoDir, "ensembl.geneLength.gz")
    }
    assertFile(annotFile)
    assertFile(lenFile)
    if (anno == "refseq") {
      ## in the current file, some gene names are not present,
      ## they will cause parsing failures
      suppressWarnings(annotTbl <- readr::read_tsv(
        annotFile,
        col_names = c("GeneID", "GeneSymbol", "GeneName"),
        col_types = "icc"
      ))
      annotTbl <- mutate(annotTbl, FeatureID=GeneID) %>%
        select("FeatureID", everything())
    } else if (anno == "ensembl") {
      suppressWarnings(annotTbl <- readr::read_tsv(
        annotFile,
        col_names = c("EnsemblID", "GeneSymbol"),
        col_types = "cc"
      ))
      annotTbl <- mutate(annotTbl, FeatureID=EnsemblID) %>%
        select("FeatureID", everything())
    }
    lenTbl <- readr::read_tsv(lenFile,
                              col_names = TRUE,
                              col_types = "cnnnn")
    res <- merge(annotTbl, lenTbl,
                 by.x = "FeatureID", by.y = colnames(lenTbl)[1])
    rownames(res) <- as.character(res$FeatureID)
    return(res)
  }

#' Read a Biokit output directory into a DGEList object for downstream analysis
#' 
#' 
#' @param dir Biokit output directory
#' @param anno Annotation type, either \code{refseq} or \code{ensembl} is
#'   supported
#' @param useCollapsedData Logical, \code{FALSE} as default. If set to 
#'   \code{TRUE}, counts are collapsed by gene symbols. This is not recommended
#'   because gene symbols are not stable identifiers.
#' @examples
#' 
#' ##... (TODO: add a mock output directory in testdata)
#' 
#' @export readBiokitAsDGEList
readBiokitAsDGEList <- function(dir, 
                                anno=c("refseq", "ensembl"),
                                useCollapsedData=FALSE) {
  ## read gct file
  anno <- match.arg(anno)
  if(useCollapsedData) {
    countType <- "count_collapsed"
    tpmType <- "tpm_collapsed"
  } else {
    countType <- "count"
    tpmType <- "tpm"
  }
  countMat <- readBiokitGctFile(dir, anno=anno, type=countType)
  tpmMat <- readBiokitGctFile(dir, anno=anno, type=tpmType)
  
  stopifnot(identical(colnames(countMat), colnames(tpmMat)))
  if(!identical(rownames(countMat), rownames(tpmMat))) {
    if(setequal(rownames(countMat), rownames(tpmMat))) {
      tpmMat <- tpmMat[as.character(rownames(countMat)),,drop=FALSE]
    } else {
      warning(paste("Count matrix and TPM matrix have different row names!",
        "The TPM matrix is newly organized"))
      commonFeat <- as.character(intersect(rownames(countMat), 
                                           rownames(tpmMat)))
      tpmUniqFeat <- as.character(setdiff(rownames(countMat), 
                                          rownames(tpmMat)))
      tpmNewMat <- countMat
      tpmNewMat[commonFeat,] <- tpmMat[commonFeat,]
      tpmNewMat[tpmUniqFeat,] <- NA
      tpmMat <- tpmNewMat
    }
  }
  stopifnot(identical(rownames(countMat), rownames(tpmMat)))
  
  ## sample annotation
  annot <- readBiokitPhenodata(dir)
  annotSampleName <- rownames(annot)
  if(!setequal(annotSampleName , colnames(countMat))) {
    stop("SampleID-group and gct file sample names do not match. Contact the developer.")
  } else {
    countMat <- countMat[, annotSampleName, drop=FALSE]
    tpmMat <- tpmMat[, annotSampleName, drop=FALSE]
  }
  
  ## feature annotation
  genes <- readBiokitFeatureAnnotation(dir, anno=anno)
  if(!setequal(rownames(countMat), rownames(genes))) {
    warnings("FeatureIDs different bewteen gct file and feature annotation")
    genes <- genes[as.character(rownames(countMat)),]
    rownames(genes) <- rownames(countMat)
  }
  stopifnot(identical(rownames(countMat), rownames(genes)))
            
  ## remove the 3rd (group) column: 
  ## it will be added by the DGEList function below
  annotSampleGroup <- annot[, 3L]
  annot <- annot[, -3L]
  res <- DGEList(counts=countMat, samples=annot, genes=genes, 
                 group = annotSampleGroup)
  res$tpm <- tpmMat
  res$BiokitAnno <- anno
  return(res)
}
